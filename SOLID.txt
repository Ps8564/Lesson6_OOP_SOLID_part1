Разобрать представленный код из семинара 4 и прокомментируем его с точки зрения принципов SOLID.

1.Принцип единственной ответственности (Single Responsibility Principle, SRP):
 - Класс Teacher отвечает только за хранение и управление данными учителя, что соответствует принципу SRP.
 - Класс TeacherController отвечает за взаимодействие с пользовательским интерфейсом и управление бизнес-логикой, что также соответствует принципу SRP.
 - Класс TeacherService отвечает за бизнес-логику, связанную с учителями, что соответствует принципу SRP.
 - Класс TeacherView отвечает только за вывод данных на консоль, что соответствует принципу SRP.

2.Принцип открытости/закрытости (Open/Closed Principle, OCP):
 - Интерфейсы UserController, UserService и UserView являются открытыми для расширения, так как они используют обобщенные типы T extends User. Это позволяет легко добавлять новые    типы пользователей, не нарушая существующий код, что соответствует принципу OCP.
 - Класс TeacherController реализует интерфейс UserController<Teacher>, что позволяет использовать его для работы с учителями, не нарушая принцип OCP.

3.Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP):
 - Класс Teacher наследуется от класса User, что соответствует принципу LSP, так как объект типа Teacher может быть использован везде, где ожидается объект типа User.

4.Принцип разделения интерфейсов (Interface Segregation Principle, ISP):
 - Интерфейсы UserController, UserService и UserView разделены по ответственности, что соответствует принципу ISP. Каждый интерфейс отвечает за определенный набор функций, что   позволяет легко добавлять новые типы пользователей, не нарушая существующий код.

5.Принцип инверсии зависимостей (Dependency Inversion Principle, DIP):
 - Классы TeacherController, TeacherService и TeacherView зависят от интерфейсов UserController, UserService и UserView соответственно. Это соответствует принципу DIP, так как высокоуровневые модули (контроллер, сервис, вью) не зависят от низкоуровневых модулей (конкретные реализации), а оба зависят от абстракций.
Таким образом, представленный код демонстрирует применение принципов SOLID, что делает его более гибким, расширяемым и легко поддерживаемым.
